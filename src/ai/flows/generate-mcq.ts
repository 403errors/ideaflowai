// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview A flow to generate adaptive multiple-choice questions (MCQs) based on user input and context.
 *
 * - generateAdaptiveMCQ - A function that generates MCQs.
 * - GenerateAdaptiveMCQInput - The input type for the generateAdaptiveMCQ function.
 * - GenerateAdaptiveMCQOutput - The return type for the generateAdaptiveMCQ function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const GenerateAdaptiveMCQInputSchema = z.object({
  ideaSummary: z.string().describe('The summarized idea extracted from the user input.'),
  category: z
    .enum(['UI/UX', 'Features', 'Flow & Extras'])
    .describe('The category of questions to generate.'),
  previousAnswers: z
    .record(z.string(), z.string())
    .optional()
    .describe('The previous answers provided by the user, mapping question to answer.'),
});

export type GenerateAdaptiveMCQInput = z.infer<typeof GenerateAdaptiveMCQInputSchema>;

const GenerateAdaptiveMCQOutputSchema = z.object({
  questions: z.array(
    z.object({
      question: z.string().describe('The multiple-choice question.'),
      options: z.array(z.string()).describe('The options for the question.'),
      recommendedOption: z.string().describe('The AI recommended option for this question'),
    })
  ).describe('The generated multiple-choice questions.'),
});

export type GenerateAdaptiveMCQOutput = z.infer<typeof GenerateAdaptiveMCQOutputSchema>;

export async function generateAdaptiveMCQ(input: GenerateAdaptiveMCQInput): Promise<GenerateAdaptiveMCQOutput> {
  return generateAdaptiveMCQFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateAdaptiveMCQPrompt',
  input: {schema: GenerateAdaptiveMCQInputSchema},
  output: {schema: GenerateAdaptiveMCQOutputSchema},
  prompt: `You are an expert AI product manager and consultant designed to help non-technical users build the absolute best version of their application idea. Your task is to generate insightful, non-technical multiple-choice questions to refine the app concept.

Your goal is to bring out the best in the user's idea by suggesting modern best practices, innovative features, and excellent user experiences. Be thorough and cover all important aspects. The user's choices will directly influence the final application plan.

**Idea Summary:**
{{{ideaSummary}}}

**Category:**
{{{category}}}

**Previous Answers (for context):**
{{#if previousAnswers}}
  {{#each previousAnswers}}
- "{{@key}}": "{{this}}"
  {{/each}}
{{else}}
None
{{/if}}

**Your Goal for the '{{{category}}}' category:**
- **For 'UI/UX':** Generate questions about the overall aesthetic (e.g., modern, minimalist, playful), branding, user feedback mechanisms (e.g., ratings, contact forms), accessibility considerations, and the desired emotional response from users.
- **For 'Features':** Generate questions about core functionalities, "nice-to-have" features, potential monetization strategies (e.g., ads, subscriptions, one-time purchase), data handling/privacy, and user account management.
- **For 'Flow & Extras':** Generate questions that map out the user journey from start to finish. This includes onboarding, primary user actions, and potential integrations like social media sharing, push notifications, or third-party services.

**Important Rules:**
1.  **Do not repeat questions** or cover topics that are clearly defined in the idea summary or previous answers.
2.  All questions must be **easy for a non-developer to understand.** Avoid jargon.
3.  Format the output as a JSON object with a "questions" array.
4.  Each question object must include:
    - "question": The multiple-choice question.
    - "options": An array of at least 3 distinct answers.
    - "recommendedOption": The option the AI recommends based on modern best practices. **This must be one of the provided options.**
  `,
});

const generateAdaptiveMCQFlow = ai.defineFlow(
  {
    name: 'generateAdaptiveMCQFlow',
    inputSchema: GenerateAdaptiveMCQInputSchema,
    outputSchema: GenerateAdaptiveMCQOutputSchema,
  },
  async (input) => {
    const { output } = await prompt(input);
    
    if (!output || !output.questions) {
      return { questions: [] };
    }

    const validatedQuestions = output.questions.map(q => {
      // Ensure the recommended option is actually in the options list.
      // If not, default to the first option.
      if (q.options && !q.options.includes(q.recommendedOption)) {
        return { ...q, recommendedOption: q.options[0] || "" };
      }
      return q;
    }).filter(q => q.question && q.options && q.options.length > 0);


    return { questions: validatedQuestions };
  }
);
