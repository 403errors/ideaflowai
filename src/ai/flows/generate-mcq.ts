// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview A flow to generate adaptive multiple-choice questions (MCQs) based on user input and context.
 *
 * - generateAdaptiveMCQ - A function that generates MCQs.
 * - GenerateAdaptiveMCQInput - The input type for the generateAdaptiveMCQ function.
 * - GenerateAdaptiveMCQOutput - The return type for the generateAdaptiveMCQ function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const GenerateAdaptiveMCQInputSchema = z.object({
  ideaSummary: z.string().describe('The summarized idea extracted from the user input.'),
  category: z
    .enum(['UI/UX', 'Features', 'Flow & Extras'])
    .describe('The category of questions to generate.'),
  previousAnswers: z
    .record(z.string(), z.string())
    .optional()
    .describe('The previous answers provided by the user, mapping question to answer.'),
});

export type GenerateAdaptiveMCQInput = z.infer<typeof GenerateAdaptiveMCQInputSchema>;

const GenerateAdaptiveMCQOutputSchema = z.object({
  questions: z.array(
    z.object({
      question: z.string().describe('The multiple-choice question.'),
      options: z.array(z.string()).describe('The options for the question.'),
      recommendedOption: z.string().describe('The AI recommended option for this question'),
    })
  ).describe('The generated multiple-choice questions.'),
});

export type GenerateAdaptiveMCQOutput = z.infer<typeof GenerateAdaptiveMCQOutputSchema>;

export async function generateAdaptiveMCQ(input: GenerateAdaptiveMCQInput): Promise<GenerateAdaptiveMCQOutput> {
  return generateAdaptiveMCQFlow(input);
}

const prompt = ai.definePrompt({
  name: 'generateAdaptiveMCQPrompt',
  input: {schema: GenerateAdaptiveMCQInputSchema},
  output: {schema: GenerateAdaptiveMCQOutputSchema},
  prompt: `You are an expert AI assistant designed to help non-technical users flesh out their application ideas. Your task is to generate insightful, non-technical multiple-choice questions to refine the app concept.

Based on the user's initial idea, the category, and any previous answers, create a set of comprehensive questions. Be thorough and cover all important aspects to ensure the best features are considered for the application.

**Idea Summary:**
{{{ideaSummary}}}

**Category:**
{{{category}}}

**Previous Answers (for context):**
{{#if previousAnswers}}
  {{#each previousAnswers}}
- "{{@key}}": "{{this}}"
  {{/each}}
{{else}}
None
{{/if}}

**Your Goal for the '{{{category}}}' category:**
- **For 'UI/UX':** Generate questions about the overall aesthetic (e.g., modern, minimalist, playful), branding, user feedback mechanisms (e.g., ratings, contact forms), accessibility considerations, and the desired emotional response from users.
- **For 'Features':** Generate questions about core functionalities, "nice-to-have" features, potential monetization strategies (e.g., ads, subscriptions, one-time purchase), data handling/privacy, and user account management.
- **For 'Flow & Extras':** Generate questions that map out the user journey from start to finish. This includes onboarding, primary user actions, and potential integrations like social media sharing, push notifications, or third-party services.

**Important Rules:**
1.  **Do not repeat questions** or cover topics that are clearly defined in the idea summary or previous answers.
2.  All questions must be **easy for a non-developer to understand.** Avoid jargon.
3.  Format the output as a JSON object with a "questions" array.
4.  Each question object must include:
    - "question": The multiple-choice question.
    - "options": An array of at least 3 distinct answers.
    - "recommendedOption": The option the AI recommends based on modern best practices. **This must be one of the provided options.**
  `,
});

const generateAdaptiveMCQFlow = ai.defineFlow(
  {
    name: 'generateAdaptiveMCQFlow',
    inputSchema: GenerateAdaptiveMCQInputSchema,
    outputSchema: GenerateAdaptiveMCQOutputSchema,
  },
  async (input) => {
    const { output } = await prompt(input);
    
    if (!output || !output.questions) {
      return { questions: [] };
    }

    const validatedQuestions = output.questions.map(q => {
      // Ensure the recommended option is actually in the options list.
      // If not, default to the first option.
      if (q.options && !q.options.includes(q.recommendedOption)) {
        return { ...q, recommendedOption: q.options[0] || "" };
      }
      return q;
    }).filter(q => q.question && q.options && q.options.length > 0);


    return { questions: validatedQuestions };
  }
);
